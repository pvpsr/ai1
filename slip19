Q.1)  Write a program to implement Hangman game using python. 
Description: 
Hangman is a classic word-guessing game. The user should guess the word correctly by 
entering alphabets of the user choice. The Program will get input as single alphabet from the 
user and it will matchmaking with the alphabets in the original word. 


import random

def hangman():
    print("=== HANGMAN GAME ===")

    # List of possible words
    words = ["python", "computer", "science", "hangman", "programming"]
    word = random.choice(words)

    guessed = ["_"] * len(word)
    attempts = 6
    used_letters = []

    while attempts > 0 and "_" in guessed:
        print("\nWord:", " ".join(guessed))
        print("Attempts left:", attempts)
        print("Used letters:", used_letters)

        # User guess
        guess = input("Enter a single alphabet: ").lower()

        if len(guess) != 1 or not guess.isalpha():
            print("Invalid input! Enter only one alphabet.")
            continue

        if guess in used_letters:
            print("You already tried this letter!")
            continue

        used_letters.append(guess)

        if guess in word:
            print("Good job! Letter found.")
            for i in range(len(word)):
                if word[i] == guess:
                    guessed[i] = guess
        else:
            print("Wrong guess!")
            attempts -= 1

    # Final result
    if "_" not in guessed:
        print("\nüéâ Congratulations! You guessed the word:", word)
    else:
        print("\n‚ùå Game Over! The correct word was:", word)

# Run the game
hangman()



Q.2) Write a Python program to implement A* algorithm. Refer the following graph as an Input for 
the program.


import heapq
# Graph with edge costs
graph = {
    'A': {'B': 2, 'E': 3},
    'B': {'C': 1, 'F': 9},
    'C': {},
    'D': {'F': 1},
    'E': {'D': 6},
    'F': {}
}

# Heuristic values
h = {
    'A': 11,
    'B': 6,
    'C': 99,
    'D': 1,
    'E': 7,
    'F': 0   # goal
}

def astar(start, goal):
    pq = []
    heapq.heappush(pq, (h[start], 0, start, [start]))  # (f, g, node, path)
    
    visited = set()

    while pq:
        f, g, node, path = heapq.heappop(pq)
        print(f"Visiting: {node} | g={g} | h={h[node]} | f={f}")

        if node == goal:
            print("\nGoal reached! Path:", path)
            print("Total cost:", g)
            return

        if node not in visited:
            visited.add(node)

            for neighbor in graph[node]:
                g_new = g + graph[node][neighbor]
                f_new = g_new + h[neighbor]
                heapq.heappush(pq, (f_new, g_new, neighbor, path + [neighbor]))

# Run A*
astar('A', 'F')
